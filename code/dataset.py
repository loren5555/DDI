import numpy as np
import pickle as pkl
from utils import *
from typing import Optional

class DDIDataSet:

    def __init__(self, pkl_path: str, min_sample_size: int = 1) -> None:
        '''
        Parameters
        ----------
        pkl_path : str
            Path to the dataset pickle file generated by `preprocess.py`.
        '''
        
        # load data
        self.data = pkl.load(open(pkl_path, 'rb'))
        self.num_nodes_dict = {
            'Drug': len(self.data['Drugs']),
            'Protein': len(self.data['Proteins'])
        }
        self.data['Drugs'] = self.data['Drugs'].to_frame().reset_index().reset_index().set_index('Drug_ID')
        self.data['Proteins'] = self.data['Proteins'].to_frame().reset_index().reset_index().set_index('Protein_ID')
        self.graph = get_graph(self.data)
        self.ndata = self.graph.ndata
        self.ddi_graph = self.graph['Drug', :, 'Drug']

        # drop the type which has not enough samples
        types = pd.Series(self.ddi_graph.edata[dgl.ETYPE].cpu())
        value_counts = types.value_counts()
        types_to_drop = value_counts[value_counts < min_sample_size].index
        if len(types_to_drop):
            print('Ignore DDI types:', sorted(types_to_drop), 'since they have less than', min_sample_size, 'samples')
        indices_to_drop = types[types.isin(types_to_drop)].index
        self.ddi_graph = dgl.remove_edges(self.ddi_graph, indices_to_drop)
        self.graph = combine_graphs(split_etype(self.ddi_graph), self.graph['DPI'], self.graph['PDI'], self.graph['PPI'], num_nodes_dict=self.num_nodes_dict)
        self.graph.ndata['feature'] = self.ndata['feature']

    @property
    def num_drug_features(self) -> int:
        return self.data['DrugFeatures'].shape[1]
    
    @property
    def num_protein_features(self) -> int:
        return self.data['ProteinFeatures'].shape[1]
    
    @property
    def num_ddi_types(self) -> int:
        return self.data['DDI']['Y'].nunique()
    
    @property
    def num_ddi(self) -> int:
        return self.ddi_graph.number_of_edges()
    
    @property
    def ddi_types(self) -> list[int]:
        return sorted(self.data['DDI']['Y'].unique())
    
    def fullgraph_from_ddi(self, ddi_graph: dgl.DGLGraph) -> dgl.DGLGraph:
        '''
        Parameters
        ----------
        ddi_graph : dgl.DGLGraph
            The heterogeneous graph with selected DDI edges and all DPI, PDI, PPI edges.

        Returns
        -------
        dgl.DGLGraph
            The heterogeneous graph with all DDI edges and all DPI, PDI, PPI edges.
        '''
        fullgraph = combine_graphs(split_etype(ddi_graph), self.graph['DPI'], self.graph['PDI'], self.graph['PPI'], num_nodes_dict=self.num_nodes_dict)
        dgl.utils.set_new_frames(fullgraph, node_frames=dgl.utils.extract_node_subframes(self.graph, None))
        return fullgraph
    
    def ddi_subgraph(self, eids: np.ndarray) -> dgl.DGLGraph:
        '''
        Parameters
        ----------
        eids : np.ndarray
            The edge indices of selected DDI edges.

        Returns
        -------
        dgl.DGLGraph
            The heterogeneous graph with selected DDI edges.
        '''
        return self.ddi_graph.edge_subgraph(eids)
    
    def subgraph(self, eids: np.ndarray) -> dgl.DGLGraph:
        '''
        Parameters
        ----------
        eids : np.ndarray
            The edge indices of selected DDI edges.

        Returns
        -------
        dgl.DGLGraph
            The heterogeneous graph with selected DDI edges and all DPI, PDI, PPI edges.
        '''
        return self.fullgraph_from_ddi(self.ddi_subgraph(eids))


class DDIDataLoader:

    def __init__(self, dataset: DDIDataSet, eids: np.ndarray, batch_size: Optional[int], neg_sample_rate: float = 0.1) -> None:
        '''
        Parameters
        ----------
        dataset : DDIDataSet
            The dataset.
        eids : np.ndarray
            The edge indices of the DDI graph used for training / validation / testing.
        batch_size : int
            The batch size of the dataloader.
        '''
        self.dataset = dataset
        self.batch_size = batch_size
        self.neg_sample_rate = neg_sample_rate
        if batch_size is not None:
            self.dataloader = dgl.dataloading.DataLoader(
                self.dataset.ddi_graph, 
                indices=eids,
                graph_sampler=dgl.dataloading.as_edge_prediction_sampler(
                    sampler=dgl.dataloading.NeighborSampler([-1]),
                    negative_sampler=dgl.dataloading.negative_sampler.GlobalUniform(int(round(
                        neg_sample_rate * dataset.num_ddi / batch_size
                    ))),
                    exclude='self',
                ),
                batch_size=batch_size, 
                shuffle=True, 
                drop_last=False,
                num_workers=1,
            )
        else:
            self.graph_undirected = to_bidirected(self.dataset.subgraph(eids))
            self.ddi_graph_undirected = to_bidirected(self.dataset.ddi_subgraph(eids))

    def __iter__(self) -> tuple[dgl.DGLGraph, dgl.DGLGraph, dgl.DGLGraph]:
        '''
        Returns
        -------
        tuple[dgl.DGLGraph, dgl.DGLGraph, dgl.DGLGraph]
            The heterogeneous undirected graph, positive undirected DDI graph, negative undirected DDI graph.
        '''
        if self.batch_size is None:
            yield self.graph_undirected, self.ddi_graph_undirected, to_bidirected(dgl.heterograph(
                {("Drug", "!DDI", "Drug"): dgl.sampling.global_uniform_negative_sampling(
                    self.dataset.ddi_graph, int(self.dataset.num_ddi * self.neg_sample_rate))},
                num_nodes_dict={"Drug": self.dataset.graph.number_of_nodes("Drug")}
            ))
        else:
            with self.dataloader.enable_cpu_affinity(verbose=False):
                for input_nodes, pos_pair_graph, neg_pair_graph, blocks in self.dataloader:
                    graph = to_bidirected(self.dataset.fullgraph_from_ddi(blocks[0]))
                    pos_pair_graph = to_bidirected(pos_pair_graph)
                    neg_pair_graph = to_bidirected(neg_pair_graph)
                    yield graph, pos_pair_graph, neg_pair_graph

