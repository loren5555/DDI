import numpy as np
import pickle as pkl
from utils import *
from typing import Optional

class DDIDataSet:

    def __init__(self, pkl_path: str, min_sample_size: int = 10) -> None:
        '''
        Parameters
        ----------
        pkl_path : str
            Path to the dataset pickle file generated by `preprocess.py`.
        '''
        
        # load data
        self.data = pkl.load(open(pkl_path, 'rb'))
        self.data['Drugs'] = self.data['Drugs'].reset_index().reset_index().set_index('Drug_ID')
        self.data['Proteins'] = self.data['Proteins'].reset_index().reset_index().set_index('Protein_ID')
        self.graph = get_graph(self.data)
        self.ndata = self.graph.ndata
        self.ddi_graph = self.graph['Drug', :, 'Drug']

        # drop the type which has not enough samples
        types = pd.Series(self.ddi_graph.edata[dgl.ETYPE].cpu())
        value_counts = types.value_counts()
        types_to_drop = value_counts[value_counts < min_sample_size].index
        print('Ignore DDI types:', sorted(types_to_drop), 'since they have less than', min_sample_size, 'samples')
        indices_to_drop = types[types.isin(types_to_drop)].index
        self.ddi_graph = dgl.remove_edges(self.ddi_graph, indices_to_drop)
        self.graph = combine_graphs(split_etype(self.ddi_graph), self.graph['DPI'], self.graph['PDI'], self.graph['PPI'])
        self.graph.ndata['feature'] = self.ndata['feature']

    @property
    def num_drug_features(self) -> int:
        return self.data['DrugFeatures'].shape[1]
    
    @property
    def num_protein_features(self) -> int:
        return self.data['ProteinFeatures'].shape[1]
    
    @property
    def num_ddi_types(self) -> int:
        return self.data['DDI']['Y'].nunique()
    
    @property
    def num_ddi(self) -> int:
        return self.ddi_graph.number_of_edges()
    
    @property
    def ddi_types(self) -> list[int]:
        return sorted(self.data['DDI']['Y'].unique())
    

class DDIDataLoader:

    def __init__(self, dataset: DDIDataSet, eids: np.ndarray, batch_size: Optional[int], neg_sample_rate: float = 1.0) -> None:
        '''
        Parameters
        ----------
        dataset : DDIDataSet
            The dataset.
        eids : np.ndarray
            The edge indices of the DDI graph used for training / validation / testing.
        batch_size : int
            The batch size of the dataloader.
        '''
        self.dataset = dataset
        self.batch_size = batch_size
        self.neg_sample_rate = neg_sample_rate
        if batch_size is not None:
            self.dataloader = dgl.dataloading.DataLoader(
                self.dataset.ddi_graph, 
                indices=eids,
                graph_sampler=dgl.dataloading.as_edge_prediction_sampler(
                    sampler=dgl.dataloading.NeighborSampler([-1]),
                    negative_sampler=dgl.dataloading.negative_sampler.GlobalUniform(neg_sample_rate),
                    exclude='self',
                ),
                batch_size=batch_size, 
                shuffle=True, 
                drop_last=False,
                num_workers=1,
            )
        else:
            self.ddi_graph = self.dataset.ddi_graph.edge_subgraph(eids)
            self.ddi_graph_undirected = to_bidirected(self.ddi_graph)
            self.graph = combine_graphs(
                split_etype(self.ddi_graph), 
                self.dataset.graph['DPI'], 
                self.dataset.graph['PDI'], 
                self.dataset.graph['PPI']
            )
            self.graph.ndata['feature'] = self.dataset.graph.ndata['feature']
            self.graph_undirected = to_bidirected(self.graph)

    def __iter__(self):
        if self.batch_size is None:
            yield self.graph_undirected, self.ddi_graph_undirected, to_bidirected(dgl.heterograph(
                {("Drug", "!DDI", "Drug"): dgl.sampling.global_uniform_negative_sampling(
                    self.dataset.ddi_graph, int(self.dataset.num_ddi * self.neg_sample_rate))},
                num_nodes_dict={"Drug": self.dataset.graph.number_of_nodes("Drug")}
            ))
        else:
            with self.dataloader.enable_cpu_affinity():
                for input_nodes, pos_pair_graph, neg_pair_graph, blocks in self.dataloader:
                    pos_pair_graph = to_bidirected(pos_pair_graph)
                    neg_pair_graph = to_bidirected(neg_pair_graph)
                    ddi_graph_split = split_etype(blocks[0])
                    graph = combine_graphs(ddi_graph_split, self.dataset.graph['DPI'], self.dataset.graph['PDI'], self.dataset.graph['PPI'])
                    graph.ndata['feature'] = self.dataset.graph.ndata['feature']
                    graph = to_bidirected(graph)
                    yield graph, pos_pair_graph, neg_pair_graph

